---
title: "第一回 簡易PostScriptインタプリタを作ろう"
layout: page
---
<style>
   .column{
        padding: 0.5em 1em;
        margin: 2em 0;
        color: #5d627b;
        background: white;
        border-top: solid 5px #5d627b;
        box-shadow: 0 3px 5px rgba(0, 0, 0, 0.22);
    }
</style>

# 第一回 簡易PostScriptインタプリタを作ろう

やる事

- ハッシュ、線形リスト、スタックの実装
- 簡単なインタープリタの実装
   - 言語はPost Scriptのサブセット
   - 実行可能配列（関数リテラル相当）、ifelse、repeatくらいまで
- 3000行くらい。

Post Scriptのサブセットを実装してみたいと思います。

最初はForthを実装しようとしたのですが、制御構造の実装がやや面倒なので、
その辺がよりシンプルで美しいPost Scriptに変更します。（その歴史的な理由でフォルダ名などはforth_modokiになっています。すみません）。

Post Scriptは触るとすぐわかるけど説明するとややこしい言語仕様なので、作りながら言語仕様自体の説明はしていきます。
なお、Post Scriptは全く知らなくてもOKです。

### この回の狙い

- ステートマシンの書き方を学ぶ
- 簡単なパーサーの書き方を学ぶ
- 言語の処理系を実装する事でプログラム言語自体の理解を深める
- 基本的なコレクションを実装する
- ファイルの分割とインターフェースを考える事を学ぶ
- そこそこのコードを書く過程で良いコードの書き方を学ぶ
- ついでにスタックマシンも学ぶ


# 01 intのパーサーを作ろう

とりあえずintのパーサーを作る所から始めてみましょう。
初回なので進め方の説明もします。

## githubでの作業の進め方

1. githubのアカウントを作る
2. https://github.com/karino2/c-lesson/ をforkする
3. 自分のc-lessonをローカルにcloneする
4. ローカルで、karino-orignというブランチを作って、remoteにhttps://github.com/karino2/c-lesson.git を指定する
5. 問題は毎回ローカルでブランチを作り、ブランチをgithubにはプッシュする（マスターはいじらない）

こんな感じで作業をしていきましょう。

今回の問題は、01_int_parserというブランチでやるとします。

### int_parserの問題をやってみよう

sources/forth_modoki/01_int_parser/int_parser.c を修正しassertを通るようにしてcommitしてpushしてみて下さい。

# 02 intのパーサーを作ろう（getc編）

01では文字列をパースしました。

パーサーを作る時には、バッファにいったん読み込むか一文字ずつ取るか、という選択が最初にあります。
今回はファイルから一文字ずつ取る（つまりgetcやfgetc相当の物を使う）、という前提でパーサーを書きましょう。

今回はcl_getc()という関数をこちらで用意するのでそれを使ってください。

## パーサーとは何か

intのパーサーではそれほど考える必要もない事ですが、
今後だんだんと複雑にしてくので、ここでパーサーというものについて少し考えてみましょう。

パーサーというのは、文字を読んで行って、字句、というものに分割するものの事を言います。
字句というのはようするに「種類と値のペア」と思ってだいたい良い。
字句はトークンともいいます。

字句は数字とか記号とかを一単位とします。（以下具体例を見ていく方が分かりやすい）

### 一回の単位

使い勝手を考えると、一回parse_one()とか呼ぶと、一つ字句が返ってくるのが良い。

"1234 abc"とあったら、一回目のparse_one()では1234という数字を返し、次のparse_one()では' 'を返し、その次のparse_one()では"abc"を返すのが良い。

### 読んでしまった文字をどうするか

パーサーでは、例えば数字をパースするためには数字の一つ先の文字まで読む必要がある。
バッファに読み込んで作業するなら問題ないけれど、今回のようにcl_getc()で一文字ずつ読む場合、数字の次の文字を読んでしまった後に次のparse_one()にどう渡すか、という問題がある。

これはパーサーの性質による所だけど、標準的な文法では、いつも先読みは一文字までで大丈夫になっている。
興味のある人はLALR(1)の文法を調べると良いと思いますが、
今回はそんな難しい事は必要なくて、「一文字だけ先読みを許せばかなりいろんなものがパース出来る」という事だけ知識としてしっておけば良いと思います。

すると最後に読んだ文字、を返すようにし、次の呼び出しの時にそれを渡すようにしないといけない。
また、その文字が無ければ存在しない文字を渡す必要がある。これは'\0'で良いでしょう。


### 途中の場合は今回は考えない

また、パース対象が途中の物がありうるのか？というのもインターフェースを考える時に大切になります。
例えばユーザーが対話的に文字を入力する、というケースでは、
まだ終わってない状態でパースしたい事があるかもしれない。

そういう場合に最後のトークンは本来未確定なので、そこから再開できるようにインターフェースを考えないといけない。

ただ今回は、ハードコードした文字列でもファイルでも、いつも最後まで読み切れる、という前提でコードを書く事にします。

### 呼び出し元に返す必要があるもの

ここまでの話をまとめると、

1. 字句のタイプ
2. 字句の値
3. 読んでしまった次の文字

の三つを返す必要があります。


## 実際の作業手順

次に実際にどう進めるか、という話をしていきます。
最新のレポジトリではsources/02_int_parser_getc/が出来ているので、
この中のint_parser_getc.cを書き換えます。

### gitでfork元の更新を持ってくる

二回目なのでgitの解説を追加しておきましょう。
今回は02_int_parser_getcというブランチで作業する事にします。

まずこれを執筆中の2018/9/23日現在では、ここのサイトと同時に課題となるソースコードも更新している状態です。

そこで前問の状態から私がいろいろ更新しているので、新しく問題を解く時には、私の最新版を取ってきて、そこからブランチを作ります。

まず、karino-originに私の最新版を持ってきます。

```
git checkout karino-origin
git pull
```

次に、masterをkarino-originと同じ状態にします。

```
git checkout master
git merge karino-origin
```

一応github上のmasterを更新しておきます。

```
git push
```

次にこのmasterから今回用のブランチを作ります。

```
git checkout -b 02_int_parser_getc
```

このように、karino-originとmasterはいつも私のレポジトリの最新版と同じにして、
問題を解くときはその時点の最新版のmasterからブランチを作って下さい。

### 作業の進め方

まず字句のタイプを表すenumを作りましょう。NUMBERとSPACEでいいと思います。

次にparse_one関数を作りましょう。
字句の種類と値と先読みしてしまった文字を返す必要があります。

returnで先読みしてしまった文字を返し、字句の種類と値は引数で返しましょう。
返す用の引数はout_という名前にします。例えばint *out_val, int *out_typeなどです。

このparse_oneの型が決まったら一旦enumと合わせてslackで見せて下さい。

次にこのparse_oneを実装して、それを使うコードを書きます。

今回はPost Scriptを実装するので、連続するスペースは一つにしてしまって構いません。
parse_oneを'1  2'とスペースが二つある所に呼んでも、三回目は2を返してください。
二回目の値はスペース一つのフリをする、でOKです。


## Unit Testを書こう

とりあえずparse_oneの実装が出来て動いたら、Unit Testも書けるようにします。
（本来は順番が逆で先にUnit Testを実装するのですが、今回は教える内容の都合でこの順番にしています。）

Unit Testとは成功してるとOKとだけ表示するテストです。
失敗するとどこで失敗したかを表示します。
そして関数一つとか二つとか、なるべく小さい単位のテストを書きます。

細かい書き方はおいおい説明していくとして、まずはUnit Testを書けるようにcl_getc()を拡張しましょう。

### cl_getc()に外部から入力を指定できるようにする

現状はハードコードされたinputを元に順番に文字を返すcl_getc()ですが、
Unit Testの事を考えると外から文字を設定出来る方が望ましいです。

そこで、外部から文字を設定するAPIを足しましょう。

```
void cl_getc_set_src(char* str);
```

とします。これをヘッダファイルに足してcl_get.cの中に実装を書いてください。（posを0にリセットするのを忘れずに！）

これが終わったらいったん見せて下さい。

### 基本的なUnit Testを足そう

それでは次にUnit Testを足します。
テストは最初は"123"という内容に対してparse_oneがどうふるまうべきか、というテストを書いて、mainから呼ぶ事にします。

テストの関数の名前は

```
void test_parse_one_123()
```

としましょう。

mainはこんな感じにします。

```
int main() {
    int answer1 = 0;
    int answer2 = 0;

    // ここから違う

    test_parse_one_123();

    // 入力を元に戻す
    cl_getc_set_src("123 456");

    // 以下は元どおり
    // ...

    // verity result.
    assert(answer1 == 123);
    assert(answer2 == 456);

    return 1;
```

ここまで終わったら一回見せて下さい。

### 空白のあるケースのUnit Testを足そう

次にtest_parse_one_123_456を追加しましょう。"123 456"に対してどう動くか、というテストです。

ちゃんと間の空白もテストしてください。

以後はこのUnit Testで問題を出す事にします。
それを見ながら、Unit Testとはどういう物かをなんとなく学んでいって下さい。

# 03 intとシンボルと特殊文字のパーサーを作ろう

それではここまで書いてきたパーサーを、int以外にも拡張しましょう。
とりあえず、

- 「{」
- 「}」
- 「executable name」
- 「literal name」

の4種類の要素を追加する事にします。

まず最初の二つ、「{」はOPEN_CURLY、「}」はCLOSE_CURLYというenumとしましょう（curly braceで中かっこの意味）。

ここで見かけない言葉が二つありますね。executable nameとliteral nameです。

### Post Scriptの二つのname

nameとはPost Scriptにおける変数名の事です。
abcなどですね。

Post Scriptには二つのnameがあります。
executable nameとliteral nameです。

この二つが何なのかはあとで説明します。
現時点ではパースする対象としてそういう二つがあると思ってください。
パースに必要な事だけここでは説明します。

最初に例を挙げると

**executable name**

- abc
- hello
- x
- abc123

などがexecutable nameです。変数に使われます。

**literal name**

- /abc
- /hello
- /x
- /abc123

などがliteral nameです。スラッシュで始まって、あとはexecutable nameと同じです。

厳密な言い方をするとexecutable nameは、「ローマ字で始まってスペース以外が続く文字で構成された文字列」です。

「literal name」はスラッシュで始まり、そのあとローマ字から始まる文字列です。
ここはPost Scriptはもっと変なものもnameに使えますが、サブセットという事であまり細かい仕様は決めない事にします。


簡単のため、nameは254文字以下としましょう。
255文字以上のnameは来ないものと仮定して、エラー処理などはしなくてOKです。
最初のスラッシュと最後のヌル文字も入れた256をNAME_SIZEとしてdefineしておくので、必要に応じて使ってください。

executable nameは、EXECUTABLE_NAMEというタイプで文字列をmallocして返す事にしましょう。

literal nameはLITERAL_DEFというタイプで文字列をmallocして返す事にします。
この時、先頭のスラッシュは取り除いてください。

## トークンの型を定義しよう

これまではout_valとout_typeという二つの変数で表していましたが、これを構造体にまとめる事にします。

以下のようにしたいのですが、

```
struct Token {
    enum LexicalType ltype;
    int value;
};
```

ただ今回、valueはintじゃないものも入ります。
具体的には

- int
- 一文字のchar（'{', '}', ' 'のどれか)
- mallocしたchar*へのポインタ

の三つのどれかになります。

charをintに入れるのは仕様上OKなのですが、ポインタは64bit CPUの場合入らない場合があります（C言語の仕様としては入らなくても入ってもOKなので実装依存）。

そこで、これらを全部入れる、unionを定義したいと思います。

### unionを使って複数のトークンのどれかを表す構造体を作る

さて、union。
Cの入門書には必ず書いてあるけど、読んでも構造体との違いが良くわからないものの代表ですね。

ここでまた良く分からないunionの説明を繰り返してもいいのですが、どうせ読んでもなんだか良く分からないと思う。
という事でここでは、実際に使ってみながら勝手に学んでもらう、という方針を取る事にします。

今回は以下のように定義します。

```
struct Token {
    enum LexicalType ltype;
    union {
        int number;
        char onechar;
        char *name;
    } u;
};
```

これをどう使うのか、は、03_parser/parser.cの中のparser_print_all()を読んでみて下さい。

## parse_one()を実装しよう

ここからは、parse_one()とそのUnit Testを実装してもらいます。

今回は私が構造体の定義やparse_one()のシグニチャなどを準備しておきました。
そこでまずは私の書いた内容を理解する事から始めてみてください。

### parser_print_all()を読む

まず大きな関数として、parser_print_all()というのがあります。
これはparse_one()を呼び出してトークンをprintする、という事をしています。

この中で、tokenとそのtoken.uがどう使われているかを見る事で、unionの使い方を理解してみてください。

**freeしないの？**  
parser_print_all()は、token.u.nameをfreeしてません。これはメモリリークになります。
長く動き続けるプログラムであればfreeはすべきです。
そうで無い場合にどうするか？というのは意見が割れる所で、C言語においてfreeをすべきかどうかは定期的に論争が発生します。  
　  
このシリーズでは「mainに近い方のレイヤで全て実行して終了するだけ」という場合はfreeしない事にします。また、説明上それほど重要でないと思う時もfreeしない事にします。
この辺は結構適当に決めるので、気になるなら自分でfreeしてくれてもOKです。  
　  
長く動き続ける組み込みのプログラムなどではリークは大問題なのでちゃんと全部解放出来ているのかをすごく時間をかけてチェックしますし、
この忘れは製品の回収騒ぎにまで発展し、結構な被害総額を生む事もあります。
だから組み込みで使われるC言語において、free忘れは重大違反だ…というとそうとも言い切れなく、組み込みで長く動く類のCプログラムはそもそもmalloc自体しない（そういうものが無いなど）という場合も結構あります。  
　  
Unixなどのサーバーで長くデーモンとして動くような物でもメモリリークは大問題となります。ですが、そういう用途でC言語を使う事は随分減りました。
C++であればそもそも手でdeleteを呼ぶのでは無く、スマートポインタなどを使ってスタックに置く方が正しいので、やはりfreeに相当するものを頑張ってチェックする、という機会はあまりありません。  
　  
カーネルの中やドライバなどでは相変わらずfreeし忘れは大問題です。この用途でC言語が使われる事は多く、またmallocに相当するものが必要になるものも結構ありますね。
この辺をやる人の場合は議論の余地なくfreeし忘れは大問題です。  
　  
C言語でどれくらいmallocしたものをfreeしなくてはいけないシチュエーションが多いか、は時代に依る話で、昨今は随分減ったというのが自分の認識です。
リソースの管理として終了が必要なものはあるのだから最初からしっかりクセをつけるべきだ、というのも一理あると思いますが、そこから先は宗教戦争になるので読者の皆様が好きにしたら良いでしょう。
{: .column}

### 二つのUnit Testを読む

次にUnit Testが二つだけ用意されています。
この二つを読んでみてください。
test_parse_one_number()は前回書いてもらった物とほとんど変わらないので、読めばわかると思います。

test_parse_one_empty_should_return_END_OF_FILE()は前回あまり明確に決まりを作らなかった、
空っぽのファイルを読ませたらどうふるまうべきか？という事についてのテストです。
今回は最後まで読んだ後にparse_one()を読んだら、END_OF_FILEというタイプを返すべき、という事に決めようと思います。


### まずはUnit Testを通すだけのparse_oneを実装する

既に書かれているコードの内容を理解したら、まずmainのparser_print_all()をコメントアウトし、
Unit Testを通す事から始めます。
前回とほとんと同じ内容となるので、前回のコードからコピペしてきて書いて下さい。

ここまで終わったら一度私に見せてください。


# 04 スタックを作ろう

# 05 addだけのevalループを作ろう

# 06 ハッシュでシンボルを実装しよう（defも）

# 07 実行可能配列を実装しよう（ここが大変）

# 08 条件分岐とスタック操作とループを足そう


